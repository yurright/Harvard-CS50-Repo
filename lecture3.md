# Lecture 3: Algorithms

## Linear Search

## Binary Search

## Running Time
- worst case(upper bound): O(n2), O(n logn) O(n) O(log n) O(1)
- on the order of n
- best case(lower bound): omega(n2), ...
- omega of one
- algorithm with identical upper bound and lower bound: theta
- in theta of n
- big O, omega, theta

## Cannot == compare strings
- so is solidity, why?
- can by using string library

## Sorting
- input unsorted data to output sorted data

## Selection Sort
keep saving the smallest, and swap
O(n2)
omega(n2)
theta(n2)

## Bubble Sort
O(n2)
omega(n)

## Merge Sort
- use recursion



## How to compare algoritms?
- by number of compares

# Questions
- what is theta
- how to define your own data type in JS, Solidity, ?
- why is C not object-oriented programming?
